import 'package:flutter/material.dart';
import 'package:flutter_hooks/flutter_hooks.dart';
import 'package:hooks_riverpod/hooks_riverpod.dart';
import 'package:yomikun/core/name_lookup.dart';
import 'package:yomikun/models/query_result.dart';
import 'package:yomikun/providers/core_providers.dart';

/// User search text.
final searchTextProvider = StateProvider<String>((_) => '');

/// User mode.
final queryModeProvider = StateProvider<QueryMode>((_) => QueryMode.sei);

/// Available query modes for the current text string.
final allowedQueryModesProvider = FutureProvider<List<QueryMode>>((ref) async {
  final text = ref.watch(searchTextProvider);
  final db = ref.read(databaseProvider);

  return await getAllowedQueryModes(db, text);
});

/// Represents the Query generated by the SearchBox. Can be listened to.
/// TODO handle 'no results' halfway - should preserve existing mode.
final queryProvider = FutureProvider<Query>((ref) async {
  final text = ref.watch(searchTextProvider).trim();
  QueryMode mode = ref.watch(queryModeProvider);
  final allowedQueryModes = await ref.watch(allowedQueryModesProvider.future);

  if (!allowedQueryModes.contains(mode)) {
    // The text has changed and the previously selected mode is no longer valid
    mode = allowedQueryModes.first;
    ref.read(queryModeProvider.notifier).state = mode;
  }

  return Query(text, mode);
});

/// Allows the user to change the search query and mode.
class SearchBox extends HookConsumerWidget {
  const SearchBox({Key? key}) : super(key: key);

  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final controller = useTextEditingController();
    useEffect(() {
      void listener() {
        ref.read(searchTextProvider.notifier).state = controller.text;
      }

      controller.addListener(listener);
      return () => controller.removeListener(listener);
    }, [controller]);

    return Row(children: [
      Expanded(
          child: TextField(
        controller: controller,
        autofocus: true,
        textInputAction: TextInputAction.search,
        autocorrect: false,
        textCapitalization: TextCapitalization.none,
        decoration: InputDecoration(
          filled: true,
          fillColor: Theme.of(context).primaryColorLight,
          suffixIcon: IconButton(
            icon: const Icon(Icons.clear),
            onPressed: () => controller.clear(),
          ),
        ),
      )),
      const SizedBox(width: 10),
      QueryModeButton(),
    ]);
  }
}

class QueryModeButton extends HookConsumerWidget {
  @override
  Widget build(BuildContext context, WidgetRef ref) {
    final queryMode = ref.watch(queryModeProvider);
    return IconButton(
      icon: Text(_queryModeToIcon(queryMode)),
      onPressed: () => advanceMode(ref),
      iconSize: 30,
      tooltip: 'Change query mode',
    );
  }

  void advanceMode(WidgetRef ref) async {
    final allowedModes = await ref.read(allowedQueryModesProvider.future);
    final currentMode = ref.read(queryModeProvider);

    int index = allowedModes.indexOf(currentMode);
    int newIndex = (index + 1) % allowedModes.length;
    ref.read(queryModeProvider.notifier).state = allowedModes[newIndex];
  }

  String _queryModeToIcon(QueryMode mode) {
    switch (mode) {
      case QueryMode.mei:
        return '名';
      case QueryMode.sei:
        return '姓';
      case QueryMode.wildcard:
        return '＊';
      case QueryMode.person:
        return '人';
    }
  }
}
