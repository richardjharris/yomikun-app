import 'package:flutter/widgets.dart';
import 'package:flutter_riverpod/flutter_riverpod.dart';
import 'package:yomikun/core/name_lookup.dart';
import 'package:yomikun/models/query.dart';
import 'package:yomikun/models/query_mode.dart';
import 'package:yomikun/providers/core_providers.dart';

/// User search text.
final searchTextProvider = ChangeNotifierProvider<TextEditingController>((ref) {
  return TextEditingController(text: '');
});

/// User mode.
final queryModeProvider = StateProvider<QueryMode>((_) => QueryMode.sei);

/// Available query modes for the current text string.
final allowedQueryModesProvider = FutureProvider<List<QueryMode>>((ref) async {
  String text = ref.watch(searchTextProvider).text;
  final db = ref.read(databaseProvider);

  return await getAllowedQueryModes(db, text);
});

/// Indicates if mode is sei and mei is available (or vice versa).
final queryModeAltAvailableProvider = FutureProvider<bool>((ref) async {
  QueryMode mode = ref.watch(queryModeProvider);
  final allowedQueryModes = await ref.watch(allowedQueryModesProvider.future);

  if (mode == QueryMode.sei && allowedQueryModes.contains(QueryMode.mei)) {
    return true;
  } else if (mode == QueryMode.mei &&
      allowedQueryModes.contains(QueryMode.sei)) {
    return true;
  } else {
    return false;
  }
});

/// Represents the Query generated by the SearchBox. Can be listened to.
/// TODO handle 'no results' halfway - should preserve existing mode.
final queryProvider = FutureProvider<Query>((ref) async {
  String text = ref.watch(searchTextProvider).text.trim();
  print('queryProvider:' + text);
  QueryMode mode = ref.watch(queryModeProvider);
  final allowedQueryModes = await ref.watch(allowedQueryModesProvider.future);

  if (!allowedQueryModes.contains(mode)) {
    // The text has changed and the previously selected mode is no longer valid
    mode = allowedQueryModes.first;
    ref.read(queryModeProvider.notifier).state = mode;
  }

  return Query(text, mode);
});
